<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Java,面试," />










<meta name="description" content="2018年1月31日面试经历今天面了一家公司，说实话是我面试经历以来最愉快的一次面试经历，在以往的面试中，面试官无非就是问一些老生常谈或者直接从网上搜索的一些面试题，没有深度并且是很少用或者压根就用不着的一些东西，不注重技术问的就像是初中高中考试一样需要死记硬背的东西，在我认为，这些东西固然重要，但是比这些更重要的，是">
<meta name="keywords" content="Java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="记一次面试经历">
<meta property="og:url" content="http://lizx.top/2018/02/02/IT杂谈/记一次面试经历/index.html">
<meta property="og:site_name" content="Pyctay">
<meta property="og:description" content="2018年1月31日面试经历今天面了一家公司，说实话是我面试经历以来最愉快的一次面试经历，在以往的面试中，面试官无非就是问一些老生常谈或者直接从网上搜索的一些面试题，没有深度并且是很少用或者压根就用不着的一些东西，不注重技术问的就像是初中高中考试一样需要死记硬背的东西，在我认为，这些东西固然重要，但是比这些更重要的，是一个人的思想和技术深度，如果去网上背一些面试题就能找到好工作，那程序员的门槛也太">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://lizx.top/img/面试/执行结果.png">
<meta property="og:image" content="http://lizx.top/img/面试/执行结果2.png">
<meta property="og:image" content="http://lizx.top/img/heap/heap.jpg">
<meta property="og:image" content="http://lizx.top/img/heap/gc.jpg">
<meta property="og:image" content="http://lizx.top/img/code.jpg">
<meta property="og:updated_time" content="2018-02-02T12:17:07.930Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记一次面试经历">
<meta name="twitter:description" content="2018年1月31日面试经历今天面了一家公司，说实话是我面试经历以来最愉快的一次面试经历，在以往的面试中，面试官无非就是问一些老生常谈或者直接从网上搜索的一些面试题，没有深度并且是很少用或者压根就用不着的一些东西，不注重技术问的就像是初中高中考试一样需要死记硬背的东西，在我认为，这些东西固然重要，但是比这些更重要的，是一个人的思想和技术深度，如果去网上背一些面试题就能找到好工作，那程序员的门槛也太">
<meta name="twitter:image" content="http://lizx.top/img/面试/执行结果.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lizx.top/2018/02/02/IT杂谈/记一次面试经历/"/>





  <title>记一次面试经历 | Pyctay</title>
  









</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pyctay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lizx.top/2018/02/02/IT杂谈/记一次面试经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pyctay">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pyctay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">记一次面试经历</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T10:51:58+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序人生/" itemprop="url" rel="index">
                    <span itemprop="name">程序人生</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="2018年1月31日面试经历"><a href="#2018年1月31日面试经历" class="headerlink" title="2018年1月31日面试经历"></a>2018年1月31日面试经历</h2><p>今天面了一家公司，说实话是我面试经历以来最愉快的一次面试经历，在以往的面试中，面试官无非就是问一些老生常谈或者直接从网上搜索的一些面试题，没有深度并且是很少用或者压根就用不着的一些东西，不注重技术问的就像是初中高中考试一样需要死记硬背的东西，在我认为，这些东西固然重要，但是比这些更重要的，是一个人的思想和技术深度，如果去网上背一些面试题就能找到好工作，那程序员的门槛也太低了一些。API是一个工具，而不是需要死记硬背的教科书，我们需要理解它而不是倒背如流。今天面试的这家不一样，比较注重技术深度，在与面试官交流的一个多小时，也使我学到了挺多东西，从心底讲我是非常愿意在这家公司工作的。在面试的过程中，也遇到了一些我不会的东西，所以我就回来之后学习了一些今天面试的内容，大概列出了几条来详细解析一下。</p>
<h2 id="int-i-Integer-valueOf-“1”-有什么不好之处？怎么优化"><a href="#int-i-Integer-valueOf-“1”-有什么不好之处？怎么优化" class="headerlink" title="int i = Integer.valueOf(“1”)有什么不好之处？怎么优化"></a><strong>int i = Integer.valueOf(“1”)有什么不好之处？怎么优化</strong></h2><p>众所周知，Java中有自动拆装箱，从Java1.5开始引入，目的是将原始类型值转自动地转换成对应的对象。自动装箱与拆箱的机制可以让我们在Java的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。这道题目主要是考察的自动拆装箱的知识。<br>我们首先来看一下valueOf的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(String s) throws NumberFormatException &#123;</span><br><span class="line">    return Integer.valueOf(parseInt(s, 10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，在valueOf中是调用了parseInt方法，并且返回的是一个int的包装类型integer的，让我们再看一下parseInt的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static int parseInt(String s, int radix)</span><br><span class="line">            throws NumberFormatException</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * WARNING: This method may be invoked early during VM initialization</span><br><span class="line">     * before IntegerCache is initialized. Care must be taken to not use</span><br><span class="line">     * the valueOf method.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (s == null) &#123;</span><br><span class="line">        throw new NumberFormatException(&quot;null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">        throw new NumberFormatException(&quot;radix &quot; + radix +</span><br><span class="line">                                        &quot; less than Character.MIN_RADIX&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        throw new NumberFormatException(&quot;radix &quot; + radix +                                                     </span><br><span class="line">                                        &quot; greater than Character.MAX_RADIX&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    boolean negative = false;</span><br><span class="line">    int i = 0, len = s.length();</span><br><span class="line">    int limit = -Integer.MAX_VALUE;</span><br><span class="line">    int multmin;</span><br><span class="line">    int digit;</span><br><span class="line"></span><br><span class="line">    if (len &gt; 0) &#123;</span><br><span class="line">        char firstChar = s.charAt(0);</span><br><span class="line">        if (firstChar &lt; &apos;0&apos;) &#123; // Possible leading &quot;+&quot; or &quot;-&quot;</span><br><span class="line">            if (firstChar == &apos;-&apos;) &#123;</span><br><span class="line">                negative = true;</span><br><span class="line">                limit = Integer.MIN_VALUE;</span><br><span class="line">            &#125; else if (firstChar != &apos;+&apos;)</span><br><span class="line">                throw NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">            if (len == 1) // Cannot have lone &quot;+&quot; or &quot;-&quot;</span><br><span class="line">                throw NumberFormatException.forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        while (i &lt; len) &#123;</span><br><span class="line">            // Accumulating negatively avoids surprises near MAX_VALUE</span><br><span class="line">            digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">            if (digit &lt; 0) &#123;</span><br><span class="line">                throw NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            if (result &lt; multmin) &#123;</span><br><span class="line">                throw NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result *= radix;</span><br><span class="line">            if (result &lt; limit + digit) &#123;</span><br><span class="line">                throw NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return negative ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很长，但是我们只看返回值是一个int类型的，所以在valueOf中首先调用了parseInt将String类型转换成了int类型，然后在valueOf中进行了自动装箱，将原始类型int转换成了对应的integer类型，然后在int i = Integer.valueOf(“1”)中，又进行了一次拆箱操作，将integer转换成了int类型，这样做虽然能完成需求，但是自动拆装箱是需要时间的，因此这段代码中是可以优化的，我们可以直接调用parseInt来将String转换成int。省去了一次装箱和一次拆箱的操作，让我们再以代码来看看这两个方法在实际应用中的表现，思路为将int i = Integer.valueOf(“1”)和int i = Integer.parseInt(“1”)循环运行20000000次，然后在循环前调用一下System.currentTimeMillis()获取当前时间，在执行完循环再调用一下System.currentTimeMillis()获取当前时间，然后两个long相减就能获取到执行代码20000000次所需要的时间，但是我在实际操作中，有出现了使用valueOf比parseInt时间少的情况，但是一次两次的情况不等于全部情况，所以我就在main方法中调用了一百次，然后使两个方法所花费的时间相减，看看执行一百次两个方法执行20000000次的结果，代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自动拆装箱效率对比</span><br><span class="line"> *</span><br><span class="line"> * @date 2018/2/2 11:09:48</span><br><span class="line"> * @auther Pyctay</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int parseIntWin = 0;</span><br><span class="line">        int valueOfWin = 0;</span><br><span class="line">        int draw = 0;</span><br><span class="line">        for(int i = 0;i&lt;100;i++) &#123;</span><br><span class="line">            long parseIntSpend = testParseInt();</span><br><span class="line">            long valueOfSpend = testValueOf();</span><br><span class="line">            if(parseIntSpend-valueOfSpend &gt; 0)</span><br><span class="line">                valueOfWin += 1;</span><br><span class="line">            else if(parseIntSpend-valueOfSpend &lt; 0)</span><br><span class="line">                parseIntWin += 1;</span><br><span class="line">            else if(parseIntSpend-valueOfSpend == 0)</span><br><span class="line">                draw +=1;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;parseInt效率高&quot; + parseIntWin + &quot;次，valueOf效率高&quot; + valueOfWin + &quot;次，平局&quot; + draw + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long testValueOf()&#123;</span><br><span class="line">        long start ;</span><br><span class="line">        long end;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;20000000; i++)&#123;</span><br><span class="line">            int j = Integer.valueOf(&quot;1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        long total = end - start;</span><br><span class="line">        System.out.println(&quot;使用valueOf方法总时间为：&quot; + total);</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long testParseInt()&#123;</span><br><span class="line">        long start ;</span><br><span class="line">        long end;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        for(int i=0; i&lt;20000000; i++)&#123;</span><br><span class="line">            int j = Integer.parseInt(&quot;1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        long total = end - start;</span><br><span class="line">        System.out.println(&quot;使用parseInt方法总时间为：&quot; + total);</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果:<br><img src="/img/面试/执行结果.png" alt="“执行结果”"><br>在我多次运行这个测试类时，情况大多维持在95:5左右，由此可见parseInt的效率是高于valueOf的。在此测试类中，我本来是执行10000次的，但是结果很不明显，不能代表实际情况，但是如果数字太大的话执行时间太长。数字越大的话差异就能很好的表现出来，就能很好的代表真实情况。下面是一个运行200000000次的结果：<br><img src="/img/面试/执行结果2.png" alt="“执行结果”"><br>parseInt完胜。</p>
<h2 id="在catch中一般都做什么"><a href="#在catch中一般都做什么" class="headerlink" title="在catch中一般都做什么"></a><strong>在catch中一般都做什么</strong></h2><p>在异常体系中，异常处理是非常占用系统资源的，在我认为，能在正常逻辑中做的事情一定不要放在异常中做，在开发阶段，我们在catch中仅仅打印日志，好让我们能够准确的定位异常发生的位置，对代码进行修改，尽量避免异常的发生，但是如果这些异常不是仅仅靠改造代码来避免的呢？（比如停电、断网等）那么我们就需要在代码中尽力处理，对发生的异常进行修正等，以防出现更严重的后果。</p>
<h2 id="Java中垃圾回收流程"><a href="#Java中垃圾回收流程" class="headerlink" title="Java中垃圾回收流程"></a>Java中垃圾回收流程</h2><p>Java的垃圾回收分为三个区域新生代 老年代 永久代<br><img src="/img/heap/heap.jpg" alt="“堆内存”"><br>当一个对象创建的时候，首先去Eden区中看看有没有内存，<br>如果有的话，就直接存储，不进行垃圾回收。<br>如果Eden区内存已满,会进行一次minor gc<br>然后再进行判断Eden区中的内存是否足够<br>如果不足 则去看存活区的内存是否足够.<br>如果内存足够,把Eden区部分活跃对象保存在存活区,然后把对象保存在Eden区.<br>如果内存不足,向老年代发送请求,查询老年代的内存是否足够<br>如果老年代内存足够,将部分存活区的活跃对象存入老年代.然后把Eden区的活跃对象放入存活区,对象依旧保存在Eden区.<br>如果老年代内存不足,会进行一次full gc,之后老年代会再进行判断 内存是否足够,如果足够 同上.<br>如果不足 会抛出OutOfMemoryError.<br><img src="/img/heap/gc.jpg" alt="“堆流程”"></p>
<h2 id="finally中的代码为什么会一定能执行到"><a href="#finally中的代码为什么会一定能执行到" class="headerlink" title="finally中的代码为什么会一定能执行到"></a>finally中的代码为什么会一定能执行到</h2><p>在Java中，编译器是通过冗余来实现finally语句块的，即把finally中的字节码”复制”到try块和所有的catch块中。</p>
<h2 id="MySQL的两种引擎"><a href="#MySQL的两种引擎" class="headerlink" title="MySQL的两种引擎"></a>MySQL的两种引擎</h2><h3 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h3><p>支持事务，并且实现SQL标准的四种隔离级别，提供行级锁和外键约束，设计目标是处理大容量数据库系统。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当需要获取表的行数时需要扫描全表，当使用事务时，就需要使用该引擎。</p>
<h3 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h3><p>该引擎是MySQL的默认引擎，不支持事务，也不支持行级锁和外键，因此当插入或更新时效率会低一些，不过MyIASM中存储了表的行数，当SELECT COUNT(0) FROM TABLE时只需要直接读取已经保存好的数据而不需要全表扫描，如果表的读操作比较多并且不需要数据库事务时，可以选择该引擎。</p>
<h2 id="数据库索引建立原则"><a href="#数据库索引建立原则" class="headerlink" title="数据库索引建立原则"></a>数据库索引建立原则</h2><p>在数据库中，合理的使用索引会提高检索速度，提高系统性能，但是不正确的使用索引不但不能提高性能，并且会拖累系统。下面有几条建立索引的原则：<br>1.为经常出现在关键字order by、group by、distinct后面的字段，建立索引。<br>2.在union等集合操作的结果集字段上，建立索引。<br>3.为经常用作查询选择的字段，建立索引。<br>4.在经常用作表连接的属性上，建立索引<br>5.考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。<br>除了上述几个原则外，我们应该需要注意以下几条：<br>1.不要过多建立索引，索引虽然提高了访问速度，但是也影响了更新操作的速度，因为更新数据时，索引也需要动态维护。<br>2.不要在有大量相同取值的字段上，建立索引。（比如性别字段）<br>3.避免在取值朝一个方向增长的字段（例如：日期类型的字段）上，建立索引；对复合索引，避免将这种类型的字段放置在最前面。<br>4.对复合索引，按照字段在查询条件中出现的频度建立索引。<br>5.删除不再使用，或者很少被使用的索引。</p>
<h2 id="Spring的IOC和AOP的核心原理"><a href="#Spring的IOC和AOP的核心原理" class="headerlink" title="Spring的IOC和AOP的核心原理"></a>Spring的IOC和AOP的核心原理</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是一个容器，根据配置信息，通过Java的<strong>反射机制</strong>按照配置的依赖关系来生成需要的对象。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP的核心就是<strong>代理</strong>，在我的设计模式博文中有对代理模式的详细介绍。<a href="http://lizx.top/2018/01/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%BF%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><strong>设计模式之代理设计模式</strong></a></p>
<h2 id="单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？"><a href="#单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？" class="headerlink" title="单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？"></a>单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？</h2><p>实现方式在我另外两篇博文中有介绍，在此不再重复介绍。<br>单例模式：<a href="http://lizx.top/2018/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%BF%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><strong>设计模式之单例设计模式</strong></a><br>工厂模式：<a href="http://lizx.top/2018/01/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%BF%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"><strong>设计模式之工厂模式与抽象工厂模式（浅谈原型模式）</strong></a></p>
<h2 id="ArrayList、HashMap、LinkedList内部实现方式"><a href="#ArrayList、HashMap、LinkedList内部实现方式" class="headerlink" title="ArrayList、HashMap、LinkedList内部实现方式"></a>ArrayList、HashMap、LinkedList内部实现方式</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>通过阅读源码可知，ArrayList内部是维护了一个Object数组，在源码中，有这样三段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line">  * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line">  * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line">  * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line">  */</span><br><span class="line"> transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三段代码是一个无参构造函数，注释的意思大概为ArrayList的容量是这个数组缓冲区的长度，当元素第一次被添加时，将扩大到default_capacity,源码中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * Default initial capacity.</span><br><span class="line">  */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure></p>
<p>这也就是说，不指定ArrayList长度时，ArrayList的初始化长度为10，那么当需要增长的时候是如何操作的呢？下面我们继续看源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * @param e element to be appended to this list</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Increases the capacity to ensure that it can hold at least the</span><br><span class="line"> * number of elements specified by the minimum capacity argument.</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity the desired minimum capacity</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们调用add方法时，会调用ensureCapacityInternal方法来判断当前容量是否大于需要的容量，如果不大于则进行扩容操作（grow方法），其中最重要的是int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)这行，将旧容量+旧容量右移一位也就是旧容量/2。也就是当容量不够时，ArrayList会自动增长为当前容量的一半。同时，如果当前操作是第一次往ArrayList中添加数据时，minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)，在上面的代码中已经说明DEFAULT_CAPACITY = 10，结果肯定为minCapacity = 10，证实了初始化长度为10。<br>ArrayList还有一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当创建ArrayList时指定长度的话，会创建一个长度为指定长度的Object数组，如果指定长度为0，那么数组为一个EMPTY_ELEMENTDATA空数组，也就和调用无参构造函数没什么区别了。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList是通过节点直接彼此连接来实现的。每一个节点都包含前一个节点的引用，后一个节点的引用和节点存储的值。当一个新节点插入时，只需要修改其中保持先后关系的节点的引用即可，当删除记录时也一样。这样就带来以下有缺点：<br>操作其中对象的速度快 只需要改变连接，新的节点可以在内存中的任何地方<br>不能随即访问 虽然存在get()方法，但是这个方法是通过遍历接点来定位的所以速度慢。<br>下面是主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified element to the end of this list.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param e the element to add</span><br><span class="line"> */</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用addLast时，会调用linkLast方法，创建一个静态内部类对象，对象的三个成员分别为：item（内容）、next（下一个内容）、prev（上一个内容），然后更新last为新创建的静态内部类以供下一次使用。LinkedList没有初始大小。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> HashMap是基于哈希表的Map接口的非同步实现（当时脑子抽了，这么简单的问题没想起来…基于哈希表），HashMap采取数组加链表的存储方式来实现。在源码中，HashMap有三个构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line"> * capacity and load factor.</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity</span><br><span class="line"> * @param  loadFactor      the load factor</span><br><span class="line"> * @throws IllegalArgumentException if the initial capacity is negative</span><br><span class="line"> *         or the load factor is nonpositive</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span><br><span class="line"> * capacity and the default load factor (0.75).</span><br><span class="line"> *</span><br><span class="line"> * @param  initialCapacity the initial capacity.</span><br><span class="line"> * @throws IllegalArgumentException if the initial capacity is negative.</span><br><span class="line"> */</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span><br><span class="line"> * (16) and the default load factor (0.75).</span><br><span class="line"> */</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有几个重要的常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure></p>
<p>由常量可知，hashMap的默认长度为1&lt;&lt;4也就是16，三个构造参数分别是无参构造方法、提供初始长度的构造方法、提供初始长度和负载因子的构造方法，其中第二个构造方法是调用了第一个构造方法并且提供了默认负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f，在第一个构造方法中如果传入的长度大于MAXIMUM_CAPACITY则长度为MAXIMUM_CAPACITY，如果负载因子小于0或者不合法，则抛出IllegalArgumentException异常。<br>关于扩容的问题，主要是下面这个方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Initializes or doubles table size.  If null, allocates <span class="keyword">in</span></span><br><span class="line">   * accord with initial capacity target held <span class="keyword">in</span> field threshold.</span><br><span class="line">   * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line">   * elements from each bin must either stay at same index, or move</span><br><span class="line">   * with a power of two offset <span class="keyword">in</span> the new table.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">return</span> the table</span><br><span class="line">   */</span><br><span class="line">  final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span></span>() &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">      int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">      int oldThr = threshold;</span><br><span class="line">      int newCap, newThr = 0;</span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; 0) &#123;</span><br><span class="line">      	// 如果超过了最大值也就是1 &lt;&lt; 30，就不再扩容了</span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="built_in">return</span> oldTab;</span><br><span class="line">          &#125;</span><br><span class="line">          // 如果不超过最大值，那么就把原来的容量左移一位也就是乘以2.</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; 0) // initial capacity was placed <span class="keyword">in</span> threshold</span><br><span class="line">          newCap = oldThr;</span><br><span class="line">      <span class="keyword">else</span> &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newThr == 0) &#123;</span><br><span class="line">          <span class="built_in">float</span> ft = (<span class="built_in">float</span>)newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (int)ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line">      threshold = newThr;</span><br><span class="line">      @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">          Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">      table = newTab;</span><br><span class="line">      <span class="keyword">if</span> (oldTab != null) &#123;</span><br><span class="line">          <span class="keyword">for</span> (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K,V&gt; e;</span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                  oldTab[j] = null;</span><br><span class="line">                  <span class="keyword">if</span> (e.next == null)</span><br><span class="line">                      newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                  <span class="keyword">else</span> &#123; // preserve order</span><br><span class="line">                      Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                      Node&lt;K,V&gt; next;</span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == null)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == null)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != null);</span><br><span class="line">                      <span class="keyword">if</span> (loTail != null) &#123;</span><br><span class="line">                          loTail.next = null;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (hiTail != null) &#123;</span><br><span class="line">                          hiTail.next = null;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关键代码我已经注释，当需要扩容时，扩容至原来的两倍。</p>
<h2 id="synchronized的内部实现方式？"><a href="#synchronized的内部实现方式？" class="headerlink" title="synchronized的内部实现方式？"></a>synchronized的内部实现方式？</h2><p>首先来看JVM规范中描述：</p>
<blockquote>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
</blockquote>
<p>这段话的意思大概为：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br>monitorexit：</p>
<blockquote>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p>
</blockquote>
<p>这段话的大概意思为：</p>
<p>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p>
<p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。<br>通过上述两段的描述，我们就能大概了解synchronized的内部实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。<br>当Synchronized修饰方法时，当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
<h2 id="怎么保证访问到一个变量时都是这个变量的最新状态？"><a href="#怎么保证访问到一个变量时都是这个变量的最新状态？" class="headerlink" title="怎么保证访问到一个变量时都是这个变量的最新状态？"></a>怎么保证访问到一个变量时都是这个变量的最新状态？</h2><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<br><strong>当且仅当满足以下所有条件时，才应该使用volatile变量</strong><br>1.对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的。值例如：count++、。<br>2.该变量没有包含在具有其他变量的不变式中。<br>在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</p>
<h2 id="equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？"><a href="#equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？" class="headerlink" title="equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？"></a>equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？</h2><p>答案是两个对象equals为true时，hashCode一定相等，但是hashCode相等时，两个对象equals不一定为true。<br>关于这个问题我有一篇博文详细介绍了<a href="http://lizx.top/2018/01/15/%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E8%A6%86%E7%9B%96equals%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9/"><strong>覆盖equals需要注意的事项</strong></a><br>二维码：<img src="/img/code.jpg" alt="“请使用微信扫一扫关注”"></p>

      
    </div>
    
    
    

    

    

    
<div>
  
    ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>


  
</div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i>
 Java</a>
          
            <a href="/tags/面试/" rel="tag"><i class="fa fa-tag"></i>
 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/29/设计模式详述/设计模式之代理设计模式/" rel="next" title="设计模式之代理设计模式">
                <i class="fa fa-chevron-left"></i> 设计模式之代理设计模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/12/设计模式详述/设计模式之适配器模式/" rel="prev" title="设计模式之适配器模式">
                设计模式之适配器模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="uyan_frame"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Pyctay" />
            
              <p class="site-author-name" itemprop="name">Pyctay</p>
              <p class="site-description motion-element" itemprop="description">天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="pyctay@foxmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://fontawesome.io/icons/" title="图标库" target="_blank">图标库</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://lulou.top/" title="啊鲁鲁同学" target="_blank">啊鲁鲁同学</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://zhuzizheng.top/" title="Waiter" target="_blank">Waiter</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://wangyd.top/" title="一个小菜鸟" target="_blank">一个小菜鸟</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2018年1月31日面试经历"><span class="nav-number">1.</span> <span class="nav-text">2018年1月31日面试经历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int-i-Integer-valueOf-“1”-有什么不好之处？怎么优化"><span class="nav-number">2.</span> <span class="nav-text">int i = Integer.valueOf(“1”)有什么不好之处？怎么优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在catch中一般都做什么"><span class="nav-number">3.</span> <span class="nav-text">在catch中一般都做什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中垃圾回收流程"><span class="nav-number">4.</span> <span class="nav-text">Java中垃圾回收流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally中的代码为什么会一定能执行到"><span class="nav-number">5.</span> <span class="nav-text">finally中的代码为什么会一定能执行到</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL的两种引擎"><span class="nav-number">6.</span> <span class="nav-text">MySQL的两种引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Innodb引擎"><span class="nav-number">6.1.</span> <span class="nav-text">Innodb引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyIASM引擎"><span class="nav-number">6.2.</span> <span class="nav-text">MyIASM引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库索引建立原则"><span class="nav-number">7.</span> <span class="nav-text">数据库索引建立原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring的IOC和AOP的核心原理"><span class="nav-number">8.</span> <span class="nav-text">Spring的IOC和AOP的核心原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC"><span class="nav-number">8.1.</span> <span class="nav-text">IOC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP"><span class="nav-number">8.2.</span> <span class="nav-text">AOP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？"><span class="nav-number">9.</span> <span class="nav-text">单例模式实现方式？在什么情况下要必须保证对象的唯一性？工厂模式实现方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList、HashMap、LinkedList内部实现方式"><span class="nav-number">10.</span> <span class="nav-text">ArrayList、HashMap、LinkedList内部实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-number">10.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList"><span class="nav-number">10.2.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">10.3.</span> <span class="nav-text">HashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的内部实现方式？"><span class="nav-number">11.</span> <span class="nav-text">synchronized的内部实现方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么保证访问到一个变量时都是这个变量的最新状态？"><span class="nav-number">12.</span> <span class="nav-text">怎么保证访问到一个变量时都是这个变量的最新状态？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？"><span class="nav-number">13.</span> <span class="nav-text">equals为true，hashCode也相等么？反之，hashCode相等那么equals也一定相等么？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="/js/src/total.js"></script>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <span class="post-meta-divider">|</span>

 Powered By <a class="theme-link" target="_blank" href="">Pyctay</a>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2154785"></script>
      <!-- UY END -->
    
  





  












  





  

  

  

  
  

  

  

  

</body>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
